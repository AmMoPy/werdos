import{CONFIG}from"./config.min.js";class LimitedCache{constructor(maxSize=CONFIG.CACHE_MAX_SIZE){this.cache=new Map;this.maxSize=maxSize;this.accessOrder=new Set}set(key,value){if(this.cache.has(key)){this.accessOrder.delete(key)}else if(this.cache.size>=this.maxSize){const oldest=this.accessOrder.values().next().value;this.accessOrder.delete(oldest);this.cache.delete(oldest)}this.cache.set(key,value);this.accessOrder.add(key)}get(key){if(this.cache.has(key)){this.accessOrder.delete(key);this.accessOrder.add(key);return this.cache.get(key)}return undefined}has(key){return this.cache.has(key)}clear(){this.cache.clear();this.accessOrder.clear()}}const FileValidator={validateFiles(files){if(!files||files.length===0){throw new Error("No files selected.")}if(files.length>CONFIG.MAX_FILES){throw new Error(`Maximum ${CONFIG.MAX_FILES} files allowed at once.`)}for(const file of files){if(!CONFIG.ALLOWED_TYPES.includes(file.type)){throw new Error(`File type ${file.type} not allowed. Use: ${CONFIG.ALLOWED_TYPES.join(", ")}`)}if(!this.isValidImageFile(file)){throw new Error(`File ${file.name} is not a valid image file.`)}if(file.size>CONFIG.MAX_FILE_SIZE){throw new Error(`File ${file.name} exceeds ${CONFIG.MAX_FILE_SIZE/1024/1024}MB limit.`)}}},async isValidImageFile(file){const buffer=await file.slice(0,12).arrayBuffer();if(buffer.byteLength<4)return false;const view=new DataView(buffer);const first4=view.getUint32(0,false);if((first4&4294967040)===4292411136)return true;if(first4===2303741511)return true;if((first4&4294967040)===1195984384)return true;if(first4===1380533830&&buffer.byteLength>=12){if(view.getUint32(8,false)===1464156752)return true}return false},sanitizeFileName(fileName){return fileName.replace(/[^a-zA-Z0-9.-]/g,"_").replace(/_{2,}/g,"_").substring(0,255)}};async function getFileHash(file){if(window.crypto&&window.crypto.subtle){try{if(file.size>CONFIG.SAMPLE_THRESH){return await fastHash(file)}const arrayBuffer=await file.arrayBuffer();const hashBuffer=await crypto.subtle.digest("SHA-256",arrayBuffer);const hashArray=Array.from(new Uint8Array(hashBuffer));return hashArray.map((b=>b.toString(16).padStart(2,"0"))).join("")}catch(error){console.warn("Crypto API failed, using fallback hash")}}return`${file.name}-${file.size}-${file.lastModified||Date.now()}-${Math.random().toString(36).substr(2,9)}`}async function fastHash(file){const chunkSize=CONFIG.CHUNK_SIZE;const chunks=[file.slice(0,chunkSize),file.slice(file.size/2,file.size/2+chunkSize),file.slice(-chunkSize)];const hashPromises=chunks.map((async chunk=>{const buffer=await chunk.arrayBuffer();const hash=await crypto.subtle.digest("SHA-256",buffer);return Array.from(new Uint8Array(hash)).map((b=>b.toString(16).padStart(2,"0"))).join("")}));const hashes=await Promise.all(hashPromises);return`${file.size}-${hashes.join("-")}`}function compressImage(file){if(file.size<100*1024){return Promise.resolve(file)}return new Promise((async(resolve,reject)=>{try{const imageBitmap=await createImageBitmap(file);let{width:width,height:height}=imageBitmap;if(width>height){if(width>CONFIG.MAX_WIDTH){height*=CONFIG.MAX_WIDTH/width;width=CONFIG.MAX_WIDTH}}else{if(height>CONFIG.MAX_HEIGHT){width*=CONFIG.MAX_HEIGHT/height;height=CONFIG.MAX_HEIGHT}}const canvas=typeof OffscreenCanvas!=="undefined"?new OffscreenCanvas(width,height):document.createElement("canvas");if(canvas instanceof OffscreenCanvas){canvas.width=width;canvas.height=height}else{canvas.width=width;canvas.height=height}const ctx=canvas.getContext("2d");ctx.drawImage(imageBitmap,0,0,width,height);imageBitmap.close();if(canvas.convertToBlob){const blob=await canvas.convertToBlob({type:"image/jpeg",quality:CONFIG.JPEG_QUALITY});resolve(new File([blob],file.name,{type:"image/jpeg"}))}else{canvas.toBlob((blob=>{resolve(new File([blob],file.name,{type:"image/jpeg"}))}),"image/jpeg",CONFIG.JPEG_QUALITY)}}catch(error){reject(error)}}))}async function fetchUserIP(){try{const response=await fetch(CONFIG.IP_API_URL);const data=await response.json();return data.ip}catch(error){console.error("Failed to fetch IP address:",error);return"Unknown IP"}}class URLManager{constructor(){this.createdUrls=new Set;this.imageBitmaps=new Set}createObjectURL(blob){const url=URL.createObjectURL(blob);this.createdUrls.add(url);return url}createImageBitmap(source){return createImageBitmap(source).then((bitmap=>{this.imageBitmaps.add(bitmap);return bitmap}))}cleanup(){this.createdUrls.forEach((url=>URL.revokeObjectURL(url)));this.createdUrls.clear();this.imageBitmaps.forEach((bitmap=>bitmap.close()));this.imageBitmaps.clear()}}export{LimitedCache,FileValidator,getFileHash,compressImage,fetchUserIP,URLManager};